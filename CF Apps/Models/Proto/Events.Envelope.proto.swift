/// Generated by the Protocol Buffers 3.1.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.22
/// Source file "envelope.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct Events { }

public extension Events {
    public struct EnvelopeRoot {
        public static let `default` = EnvelopeRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Events.HttpRoot.default.registerAllExtensions(registry: extensionRegistry)
            Events.LogRoot.default.registerAllExtensions(registry: extensionRegistry)
            Events.MetricRoot.default.registerAllExtensions(registry: extensionRegistry)
            Events.ErrorRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    //// Envelope wraps an Event and adds metadata.
    final public class Envelope : GeneratedMessage {
        public typealias BuilderType = Events.Envelope.Builder

        public static func == (lhs: Events.Envelope, rhs: Events.Envelope) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasOrigin == rhs.hasOrigin) && (!lhs.hasOrigin || lhs.origin == rhs.origin)
            fieldCheck = fieldCheck && (lhs.hasEventType == rhs.hasEventType) && (!lhs.hasEventType || lhs.eventType == rhs.eventType)
            fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
            fieldCheck = fieldCheck && (lhs.hasHttpStartStop == rhs.hasHttpStartStop) && (!lhs.hasHttpStartStop || lhs.httpStartStop == rhs.httpStartStop)
            fieldCheck = fieldCheck && (lhs.hasLogMessage == rhs.hasLogMessage) && (!lhs.hasLogMessage || lhs.logMessage == rhs.logMessage)
            fieldCheck = fieldCheck && (lhs.hasValueMetric == rhs.hasValueMetric) && (!lhs.hasValueMetric || lhs.valueMetric == rhs.valueMetric)
            fieldCheck = fieldCheck && (lhs.hasCounterEvent == rhs.hasCounterEvent) && (!lhs.hasCounterEvent || lhs.counterEvent == rhs.counterEvent)
            fieldCheck = fieldCheck && (lhs.hasError == rhs.hasError) && (!lhs.hasError || lhs.error == rhs.error)
            fieldCheck = fieldCheck && (lhs.hasContainerMetric == rhs.hasContainerMetric) && (!lhs.hasContainerMetric || lhs.containerMetric == rhs.containerMetric)
            fieldCheck = fieldCheck && (lhs.hasDeployment == rhs.hasDeployment) && (!lhs.hasDeployment || lhs.deployment == rhs.deployment)
            fieldCheck = fieldCheck && (lhs.hasJob == rhs.hasJob) && (!lhs.hasJob || lhs.job == rhs.job)
            fieldCheck = fieldCheck && (lhs.hasIndex == rhs.hasIndex) && (!lhs.hasIndex || lhs.index == rhs.index)
            fieldCheck = fieldCheck && (lhs.hasIp == rhs.hasIp) && (!lhs.hasIp || lhs.ip == rhs.ip)
            fieldCheck = fieldCheck && (lhs.hasTags == rhs.hasTags) && (!lhs.hasTags || lhs.tags == rhs.tags)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class TagsEntry : GeneratedMessage {
            public typealias BuilderType = Events.Envelope.TagsEntry.Builder

            public static func == (lhs: Events.Envelope.TagsEntry, rhs: Events.Envelope.TagsEntry) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
                fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            public fileprivate(set) var key:String! = nil
            public fileprivate(set) var hasKey:Bool = false

            public fileprivate(set) var value:String! = nil
            public fileprivate(set) var hasValue:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasKey {
                    try codedOutputStream.writeString(fieldNumber: 1, value:key)
                }
                if hasValue {
                    try codedOutputStream.writeString(fieldNumber: 2, value:value)
                }
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasKey {
                    serialize_size += key.computeStringSize(fieldNumber: 1)
                }
                if hasValue {
                    serialize_size += value.computeStringSize(fieldNumber: 2)
                }
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> Events.Envelope.TagsEntry.Builder {
                return Events.Envelope.TagsEntry.classBuilder() as! Events.Envelope.TagsEntry.Builder
            }
            public func getBuilder() -> Events.Envelope.TagsEntry.Builder {
                return classBuilder() as! Events.Envelope.TagsEntry.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Events.Envelope.TagsEntry.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return Events.Envelope.TagsEntry.Builder()
            }
            public func toBuilder() throws -> Events.Envelope.TagsEntry.Builder {
                return try Events.Envelope.TagsEntry.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:Events.Envelope.TagsEntry) throws -> Events.Envelope.TagsEntry.Builder {
                return try Events.Envelope.TagsEntry.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasKey {
                    jsonMap["key"] = key
                }
                if hasValue {
                    jsonMap["value"] = value
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Events.Envelope.TagsEntry {
                return try Events.Envelope.TagsEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> Events.Envelope.TagsEntry {
                return try Events.Envelope.TagsEntry.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasKey {
                    output += "\(indent) key: \(key) \n"
                }
                if hasValue {
                    output += "\(indent) value: \(value) \n"
                }
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasKey {
                        hashCode = (hashCode &* 31) &+ key.hashValue
                    }
                    if hasValue {
                        hashCode = (hashCode &* 31) &+ value.hashValue
                    }
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "Events.Envelope.TagsEntry"
            }
            override public func className() -> String {
                return "Events.Envelope.TagsEntry"
            }
            //Meta information declaration end

            final public class Builder : GeneratedMessageBuilder {
                fileprivate var builderResult:Events.Envelope.TagsEntry = Events.Envelope.TagsEntry()
                public func getMessage() -> Events.Envelope.TagsEntry {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                public var key:String {
                    get {
                        return builderResult.key
                    }
                    set (value) {
                        builderResult.hasKey = true
                        builderResult.key = value
                    }
                }
                public var hasKey:Bool {
                    get {
                        return builderResult.hasKey
                    }
                }
                @discardableResult
                public func setKey(_ value:String) -> Events.Envelope.TagsEntry.Builder {
                    self.key = value
                    return self
                }
                @discardableResult
                public func clearKey() -> Events.Envelope.TagsEntry.Builder{
                    builderResult.hasKey = false
                    builderResult.key = nil
                    return self
                }
                public var value:String {
                    get {
                        return builderResult.value
                    }
                    set (value) {
                        builderResult.hasValue = true
                        builderResult.value = value
                    }
                }
                public var hasValue:Bool {
                    get {
                        return builderResult.hasValue
                    }
                }
                @discardableResult
                public func setValue(_ value:String) -> Events.Envelope.TagsEntry.Builder {
                    self.value = value
                    return self
                }
                @discardableResult
                public func clearValue() -> Events.Envelope.TagsEntry.Builder{
                    builderResult.hasValue = false
                    builderResult.value = nil
                    return self
                }
                override public var internalGetResult:GeneratedMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> Events.Envelope.TagsEntry.Builder {
                    builderResult = Events.Envelope.TagsEntry()
                    return self
                }
                override public func clone() throws -> Events.Envelope.TagsEntry.Builder {
                    return try Events.Envelope.TagsEntry.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> Events.Envelope.TagsEntry {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> Events.Envelope.TagsEntry {
                    let returnMe:Events.Envelope.TagsEntry = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:Events.Envelope.TagsEntry) throws -> Events.Envelope.TagsEntry.Builder {
                    if other == Events.Envelope.TagsEntry() {
                        return self
                    }
                    if other.hasKey {
                        key = other.key
                    }
                    if other.hasValue {
                        value = other.value
                    }
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Events.Envelope.TagsEntry.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Events.Envelope.TagsEntry.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            key = try codedInputStream.readString()

                        case 18:
                            value = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Events.Envelope.TagsEntry.Builder {
                    let resultDecodedBuilder = Events.Envelope.TagsEntry.Builder()
                    if let jsonValueKey = jsonMap["key"] as? String {
                        resultDecodedBuilder.key = jsonValueKey
                    }
                    if let jsonValueValue = jsonMap["value"] as? String {
                        resultDecodedBuilder.value = jsonValueValue
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> Events.Envelope.TagsEntry.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try Events.Envelope.TagsEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



            //Enum type declaration start 

            //// Type of the wrapped event.
            public enum EventType:Int32, GeneratedEnum {
                /// Removed Heartbeat at position 1
                /// Removed HttpStart at position 2
                /// Removed HttpStop at position 3
                case httpStartStop = 4
                case logMessage = 5
                case valueMetric = 6
                case counterEvent = 7
                case error = 8
                case containerMetric = 9
                public func toString() -> String {
                    switch self {
                    case .httpStartStop: return "HttpStartStop"
                    case .logMessage: return "LogMessage"
                    case .valueMetric: return "ValueMetric"
                    case .counterEvent: return "CounterEvent"
                    case .error: return "Error"
                    case .containerMetric: return "ContainerMetric"
                    }
                }
                public static func fromString(_ str:String) throws -> Events.Envelope.EventType {
                    switch str {
                    case "HttpStartStop":    return .httpStartStop
                    case "LogMessage":    return .logMessage
                    case "ValueMetric":    return .valueMetric
                    case "CounterEvent":    return .counterEvent
                    case "Error":    return .error
                    case "ContainerMetric":    return .containerMetric
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .httpStartStop: return ".httpStartStop"
                    case .logMessage: return ".logMessage"
                    case .valueMetric: return ".valueMetric"
                    case .counterEvent: return ".counterEvent"
                    case .error: return ".error"
                    case .containerMetric: return ".containerMetric"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:EventType, rhs:EventType) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        //// Unique description of the origin of this event.
        public fileprivate(set) var origin:String! = nil
        public fileprivate(set) var hasOrigin:Bool = false

        public fileprivate(set) var eventType:Events.Envelope.EventType = Events.Envelope.EventType.httpStartStop
        public fileprivate(set) var hasEventType:Bool = false
        //// UNIX timestamp (in nanoseconds) event was wrapped in this Envelope.
        public fileprivate(set) var timestamp:Int64! = nil
        public fileprivate(set) var hasTimestamp:Bool = false

        //// Deployment name (used to uniquely identify source).
        public fileprivate(set) var deployment:String! = nil
        public fileprivate(set) var hasDeployment:Bool = false

        //// Job name (used to uniquely identify source).
        public fileprivate(set) var job:String! = nil
        public fileprivate(set) var hasJob:Bool = false

        //// Index of job (used to uniquely identify source).
        public fileprivate(set) var index:String! = nil
        public fileprivate(set) var hasIndex:Bool = false

        //// IP address (used to uniquely identify source).
        public fileprivate(set) var ip:String! = nil
        public fileprivate(set) var hasIp:Bool = false

        //// key/value tags to include additional identifying information.
        public fileprivate(set) var tags:Dictionary<String,String> = Dictionary<String,String>()

        public fileprivate(set) var hasTags:Bool = false
        public fileprivate(set) var httpStartStop:Events.HttpStartStop!
        public fileprivate(set) var hasHttpStartStop:Bool = false
        public fileprivate(set) var logMessage:Events.LogMessage!
        public fileprivate(set) var hasLogMessage:Bool = false
        public fileprivate(set) var valueMetric:Events.ValueMetric!
        public fileprivate(set) var hasValueMetric:Bool = false
        public fileprivate(set) var counterEvent:Events.CounterEvent!
        public fileprivate(set) var hasCounterEvent:Bool = false
        public fileprivate(set) var error:Events.Error!
        public fileprivate(set) var hasError:Bool = false
        public fileprivate(set) var containerMetric:Events.ContainerMetric!
        public fileprivate(set) var hasContainerMetric:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasOrigin {
                return false
            }
            if !hasEventType {
                return false
            }
            if hasHttpStartStop {
                if !httpStartStop.isInitialized() {
                    return false
                }
            }
            if hasLogMessage {
                if !logMessage.isInitialized() {
                    return false
                }
            }
            if hasValueMetric {
                if !valueMetric.isInitialized() {
                    return false
                }
            }
            if hasCounterEvent {
                if !counterEvent.isInitialized() {
                    return false
                }
            }
            if hasError {
                if !error.isInitialized() {
                    return false
                }
            }
            if hasContainerMetric {
                if !containerMetric.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasOrigin {
                try codedOutputStream.writeString(fieldNumber: 1, value:origin)
            }
            if hasEventType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:eventType.rawValue)
            }
            if hasTimestamp {
                try codedOutputStream.writeInt64(fieldNumber: 6, value:timestamp)
            }
            if hasHttpStartStop {
                try codedOutputStream.writeMessage(fieldNumber: 7, value:httpStartStop)
            }
            if hasLogMessage {
                try codedOutputStream.writeMessage(fieldNumber: 8, value:logMessage)
            }
            if hasValueMetric {
                try codedOutputStream.writeMessage(fieldNumber: 9, value:valueMetric)
            }
            if hasCounterEvent {
                try codedOutputStream.writeMessage(fieldNumber: 10, value:counterEvent)
            }
            if hasError {
                try codedOutputStream.writeMessage(fieldNumber: 11, value:error)
            }
            if hasContainerMetric {
                try codedOutputStream.writeMessage(fieldNumber: 12, value:containerMetric)
            }
            if hasDeployment {
                try codedOutputStream.writeString(fieldNumber: 13, value:deployment)
            }
            if hasJob {
                try codedOutputStream.writeString(fieldNumber: 14, value:job)
            }
            if hasIndex {
                try codedOutputStream.writeString(fieldNumber: 15, value:index)
            }
            if hasIp {
                try codedOutputStream.writeString(fieldNumber: 16, value:ip)
            }
            if hasTags {
                for (keyTags, valueTags) in tags {
                    let valueOfTags = try! Events.Envelope.TagsEntry.Builder().setKey(keyTags).setValue(valueTags).build()
                      try codedOutputStream.writeMessage(fieldNumber: 17, value:valueOfTags)
                  }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasOrigin {
                serialize_size += origin.computeStringSize(fieldNumber: 1)
            }
            if (hasEventType) {
                serialize_size += eventType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasTimestamp {
                serialize_size += timestamp.computeInt64Size(fieldNumber: 6)
            }
            if hasHttpStartStop {
                if let varSizehttpStartStop = httpStartStop?.computeMessageSize(fieldNumber: 7) {
                    serialize_size += varSizehttpStartStop
                }
            }
            if hasLogMessage {
                if let varSizelogMessage = logMessage?.computeMessageSize(fieldNumber: 8) {
                    serialize_size += varSizelogMessage
                }
            }
            if hasValueMetric {
                if let varSizevalueMetric = valueMetric?.computeMessageSize(fieldNumber: 9) {
                    serialize_size += varSizevalueMetric
                }
            }
            if hasCounterEvent {
                if let varSizecounterEvent = counterEvent?.computeMessageSize(fieldNumber: 10) {
                    serialize_size += varSizecounterEvent
                }
            }
            if hasError {
                if let varSizeerror = error?.computeMessageSize(fieldNumber: 11) {
                    serialize_size += varSizeerror
                }
            }
            if hasContainerMetric {
                if let varSizecontainerMetric = containerMetric?.computeMessageSize(fieldNumber: 12) {
                    serialize_size += varSizecontainerMetric
                }
            }
            if hasDeployment {
                serialize_size += deployment.computeStringSize(fieldNumber: 13)
            }
            if hasJob {
                serialize_size += job.computeStringSize(fieldNumber: 14)
            }
            if hasIndex {
                serialize_size += index.computeStringSize(fieldNumber: 15)
            }
            if hasIp {
                serialize_size += ip.computeStringSize(fieldNumber: 16)
            }
            if hasTags {
                  for (keyTags, valueTags) in tags {
                      let valueOfTags = try! Events.Envelope.TagsEntry.Builder().setKey(keyTags).setValue(valueTags).build()
                serialize_size += valueOfTags.computeMessageSize(fieldNumber: 17)
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Events.Envelope.Builder {
            return Events.Envelope.classBuilder() as! Events.Envelope.Builder
        }
        public func getBuilder() -> Events.Envelope.Builder {
            return classBuilder() as! Events.Envelope.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Events.Envelope.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Events.Envelope.Builder()
        }
        public func toBuilder() throws -> Events.Envelope.Builder {
            return try Events.Envelope.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Events.Envelope) throws -> Events.Envelope.Builder {
            return try Events.Envelope.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasOrigin {
                jsonMap["origin"] = origin
            }
            if hasEventType {
                jsonMap["eventType"] = eventType.toString()
            }
            if hasTimestamp {
                jsonMap["timestamp"] = "\(timestamp)"
            }
            if hasDeployment {
                jsonMap["deployment"] = deployment
            }
            if hasJob {
                jsonMap["job"] = job
            }
            if hasIndex {
                jsonMap["index"] = index
            }
            if hasIp {
                jsonMap["ip"] = ip
            }
            if hasTags {
                var mapTags = Dictionary<String, String>()
                for (keyTags, valueTags) in tags {
                    mapTags["\(keyTags)"] = valueTags
                }
                jsonMap["tags"] = mapTags
            }
            if hasHttpStartStop {
                jsonMap["httpStartStop"] = try httpStartStop.encode()
            }
            if hasLogMessage {
                jsonMap["logMessage"] = try logMessage.encode()
            }
            if hasValueMetric {
                jsonMap["valueMetric"] = try valueMetric.encode()
            }
            if hasCounterEvent {
                jsonMap["counterEvent"] = try counterEvent.encode()
            }
            if hasError {
                jsonMap["error"] = try error.encode()
            }
            if hasContainerMetric {
                jsonMap["containerMetric"] = try containerMetric.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Events.Envelope {
            return try Events.Envelope.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Events.Envelope {
            return try Events.Envelope.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasOrigin {
                output += "\(indent) origin: \(origin) \n"
            }
            if (hasEventType) {
                output += "\(indent) eventType: \(eventType.description)\n"
            }
            if hasTimestamp {
                output += "\(indent) timestamp: \(timestamp) \n"
            }
            if hasHttpStartStop {
                output += "\(indent) httpStartStop {\n"
                if let outDescHttpStartStop = httpStartStop {
                    output += try outDescHttpStartStop.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasLogMessage {
                output += "\(indent) logMessage {\n"
                if let outDescLogMessage = logMessage {
                    output += try outDescLogMessage.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasValueMetric {
                output += "\(indent) valueMetric {\n"
                if let outDescValueMetric = valueMetric {
                    output += try outDescValueMetric.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCounterEvent {
                output += "\(indent) counterEvent {\n"
                if let outDescCounterEvent = counterEvent {
                    output += try outDescCounterEvent.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasError {
                output += "\(indent) error {\n"
                if let outDescError = error {
                    output += try outDescError.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasContainerMetric {
                output += "\(indent) containerMetric {\n"
                if let outDescContainerMetric = containerMetric {
                    output += try outDescContainerMetric.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasDeployment {
                output += "\(indent) deployment: \(deployment) \n"
            }
            if hasJob {
                output += "\(indent) job: \(job) \n"
            }
            if hasIndex {
                output += "\(indent) index: \(index) \n"
            }
            if hasIp {
                output += "\(indent) ip: \(ip) \n"
            }
            if hasTags {
                output += "\(indent) tags: \(tags) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasOrigin {
                    hashCode = (hashCode &* 31) &+ origin.hashValue
                }
                if hasEventType {
                     hashCode = (hashCode &* 31) &+ eventType.hashValue
                }
                if hasTimestamp {
                    hashCode = (hashCode &* 31) &+ timestamp.hashValue
                }
                if hasHttpStartStop {
                    if let hashValuehttpStartStop = httpStartStop?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuehttpStartStop
                    }
                }
                if hasLogMessage {
                    if let hashValuelogMessage = logMessage?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuelogMessage
                    }
                }
                if hasValueMetric {
                    if let hashValuevalueMetric = valueMetric?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuevalueMetric
                    }
                }
                if hasCounterEvent {
                    if let hashValuecounterEvent = counterEvent?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecounterEvent
                    }
                }
                if hasError {
                    if let hashValueerror = error?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueerror
                    }
                }
                if hasContainerMetric {
                    if let hashValuecontainerMetric = containerMetric?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecontainerMetric
                    }
                }
                if hasDeployment {
                    hashCode = (hashCode &* 31) &+ deployment.hashValue
                }
                if hasJob {
                    hashCode = (hashCode &* 31) &+ job.hashValue
                }
                if hasIndex {
                    hashCode = (hashCode &* 31) &+ index.hashValue
                }
                if hasIp {
                    hashCode = (hashCode &* 31) &+ ip.hashValue
                }
                if hasTags {
                    for (keyTags, valueTags) in tags {
                        hashCode = (hashCode &* 31) &+ keyTags.hashValue
                        hashCode = (hashCode &* 31) &+ valueTags.hashValue
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Events.Envelope"
        }
        override public func className() -> String {
            return "Events.Envelope"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Events.Envelope = Events.Envelope()
            public func getMessage() -> Events.Envelope {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            //// Unique description of the origin of this event.
            public var origin:String {
                get {
                    return builderResult.origin
                }
                set (value) {
                    builderResult.hasOrigin = true
                    builderResult.origin = value
                }
            }
            public var hasOrigin:Bool {
                get {
                    return builderResult.hasOrigin
                }
            }
            @discardableResult
            public func setOrigin(_ value:String) -> Events.Envelope.Builder {
                self.origin = value
                return self
            }
            @discardableResult
            public func clearOrigin() -> Events.Envelope.Builder{
                builderResult.hasOrigin = false
                builderResult.origin = nil
                return self
            }
            //// Type of wrapped event. Only the optional field corresponding to the value of eventType should be set.
                public var eventType:Events.Envelope.EventType {
                    get {
                        return builderResult.eventType
                    }
                    set (value) {
                        builderResult.hasEventType = true
                        builderResult.eventType = value
                    }
                }
                public var hasEventType:Bool{
                    get {
                        return builderResult.hasEventType
                    }
                }
            @discardableResult
                public func setEventType(_ value:Events.Envelope.EventType) -> Events.Envelope.Builder {
                  self.eventType = value
                  return self
                }
            @discardableResult
                public func clearEventType() -> Events.Envelope.Builder {
                   builderResult.hasEventType = false
                   builderResult.eventType = .httpStartStop
                   return self
                }
            //// UNIX timestamp (in nanoseconds) event was wrapped in this Envelope.
            public var timestamp:Int64 {
                get {
                    return builderResult.timestamp
                }
                set (value) {
                    builderResult.hasTimestamp = true
                    builderResult.timestamp = value
                }
            }
            public var hasTimestamp:Bool {
                get {
                    return builderResult.hasTimestamp
                }
            }
            @discardableResult
            public func setTimestamp(_ value:Int64) -> Events.Envelope.Builder {
                self.timestamp = value
                return self
            }
            @discardableResult
            public func clearTimestamp() -> Events.Envelope.Builder{
                builderResult.hasTimestamp = false
                builderResult.timestamp = nil
                return self
            }
            //// Deployment name (used to uniquely identify source).
            public var deployment:String {
                get {
                    return builderResult.deployment
                }
                set (value) {
                    builderResult.hasDeployment = true
                    builderResult.deployment = value
                }
            }
            public var hasDeployment:Bool {
                get {
                    return builderResult.hasDeployment
                }
            }
            @discardableResult
            public func setDeployment(_ value:String) -> Events.Envelope.Builder {
                self.deployment = value
                return self
            }
            @discardableResult
            public func clearDeployment() -> Events.Envelope.Builder{
                builderResult.hasDeployment = false
                builderResult.deployment = nil
                return self
            }
            //// Job name (used to uniquely identify source).
            public var job:String {
                get {
                    return builderResult.job
                }
                set (value) {
                    builderResult.hasJob = true
                    builderResult.job = value
                }
            }
            public var hasJob:Bool {
                get {
                    return builderResult.hasJob
                }
            }
            @discardableResult
            public func setJob(_ value:String) -> Events.Envelope.Builder {
                self.job = value
                return self
            }
            @discardableResult
            public func clearJob() -> Events.Envelope.Builder{
                builderResult.hasJob = false
                builderResult.job = nil
                return self
            }
            //// Index of job (used to uniquely identify source).
            public var index:String {
                get {
                    return builderResult.index
                }
                set (value) {
                    builderResult.hasIndex = true
                    builderResult.index = value
                }
            }
            public var hasIndex:Bool {
                get {
                    return builderResult.hasIndex
                }
            }
            @discardableResult
            public func setIndex(_ value:String) -> Events.Envelope.Builder {
                self.index = value
                return self
            }
            @discardableResult
            public func clearIndex() -> Events.Envelope.Builder{
                builderResult.hasIndex = false
                builderResult.index = nil
                return self
            }
            //// IP address (used to uniquely identify source).
            public var ip:String {
                get {
                    return builderResult.ip
                }
                set (value) {
                    builderResult.hasIp = true
                    builderResult.ip = value
                }
            }
            public var hasIp:Bool {
                get {
                    return builderResult.hasIp
                }
            }
            @discardableResult
            public func setIp(_ value:String) -> Events.Envelope.Builder {
                self.ip = value
                return self
            }
            @discardableResult
            public func clearIp() -> Events.Envelope.Builder{
                builderResult.hasIp = false
                builderResult.ip = nil
                return self
            }
            //// key/value tags to include additional identifying information.
            public var hasTags:Bool {
                get {
                    return builderResult.hasTags
                }
            }
            public var tags:Dictionary<String,String> {
                get {
                    return builderResult.tags
                }
                set (value) {
                    builderResult.hasTags = true
                    builderResult.tags = value
                }
            }
            @discardableResult
            public func setTags(_ value:Dictionary<String,String>) -> Events.Envelope.Builder {
                self.tags = value
                return self
            }
            @discardableResult
            public func clearTags() -> Events.Envelope.Builder{
                builderResult.hasTags = false
                builderResult.tags = Dictionary<String,String>()
                return self
            }
            /// Removed Heartbeat at position 3
            /// Removed HttpStart at position 4
            /// Removed HttpStop at position 5
            public var httpStartStop:Events.HttpStartStop! {
                get {
                    if httpStartStopBuilder_ != nil {
                        builderResult.httpStartStop = httpStartStopBuilder_.getMessage()
                    }
                    return builderResult.httpStartStop
                }
                set (value) {
                    builderResult.hasHttpStartStop = true
                    builderResult.httpStartStop = value
                }
            }
            public var hasHttpStartStop:Bool {
                get {
                    return builderResult.hasHttpStartStop
                }
            }
            fileprivate var httpStartStopBuilder_:Events.HttpStartStop.Builder! {
                didSet {
                    builderResult.hasHttpStartStop = true
                }
            }
            public func getHttpStartStopBuilder() -> Events.HttpStartStop.Builder {
                if httpStartStopBuilder_ == nil {
                    httpStartStopBuilder_ = Events.HttpStartStop.Builder()
                    builderResult.httpStartStop = httpStartStopBuilder_.getMessage()
                    if httpStartStop != nil {
                        try! httpStartStopBuilder_.mergeFrom(other: httpStartStop)
                    }
                }
                return httpStartStopBuilder_
            }
            @discardableResult
            public func setHttpStartStop(_ value:Events.HttpStartStop!) -> Events.Envelope.Builder {
                self.httpStartStop = value
                return self
            }
            @discardableResult
            public func mergeHttpStartStop(value:Events.HttpStartStop) throws -> Events.Envelope.Builder {
                if builderResult.hasHttpStartStop {
                    builderResult.httpStartStop = try Events.HttpStartStop.builderWithPrototype(prototype:builderResult.httpStartStop).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.httpStartStop = value
                }
                builderResult.hasHttpStartStop = true
                return self
            }
            @discardableResult
            public func clearHttpStartStop() -> Events.Envelope.Builder {
                httpStartStopBuilder_ = nil
                builderResult.hasHttpStartStop = false
                builderResult.httpStartStop = nil
                return self
            }
            public var logMessage:Events.LogMessage! {
                get {
                    if logMessageBuilder_ != nil {
                        builderResult.logMessage = logMessageBuilder_.getMessage()
                    }
                    return builderResult.logMessage
                }
                set (value) {
                    builderResult.hasLogMessage = true
                    builderResult.logMessage = value
                }
            }
            public var hasLogMessage:Bool {
                get {
                    return builderResult.hasLogMessage
                }
            }
            fileprivate var logMessageBuilder_:Events.LogMessage.Builder! {
                didSet {
                    builderResult.hasLogMessage = true
                }
            }
            public func getLogMessageBuilder() -> Events.LogMessage.Builder {
                if logMessageBuilder_ == nil {
                    logMessageBuilder_ = Events.LogMessage.Builder()
                    builderResult.logMessage = logMessageBuilder_.getMessage()
                    if logMessage != nil {
                        try! logMessageBuilder_.mergeFrom(other: logMessage)
                    }
                }
                return logMessageBuilder_
            }
            @discardableResult
            public func setLogMessage(_ value:Events.LogMessage!) -> Events.Envelope.Builder {
                self.logMessage = value
                return self
            }
            @discardableResult
            public func mergeLogMessage(value:Events.LogMessage) throws -> Events.Envelope.Builder {
                if builderResult.hasLogMessage {
                    builderResult.logMessage = try Events.LogMessage.builderWithPrototype(prototype:builderResult.logMessage).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.logMessage = value
                }
                builderResult.hasLogMessage = true
                return self
            }
            @discardableResult
            public func clearLogMessage() -> Events.Envelope.Builder {
                logMessageBuilder_ = nil
                builderResult.hasLogMessage = false
                builderResult.logMessage = nil
                return self
            }
            public var valueMetric:Events.ValueMetric! {
                get {
                    if valueMetricBuilder_ != nil {
                        builderResult.valueMetric = valueMetricBuilder_.getMessage()
                    }
                    return builderResult.valueMetric
                }
                set (value) {
                    builderResult.hasValueMetric = true
                    builderResult.valueMetric = value
                }
            }
            public var hasValueMetric:Bool {
                get {
                    return builderResult.hasValueMetric
                }
            }
            fileprivate var valueMetricBuilder_:Events.ValueMetric.Builder! {
                didSet {
                    builderResult.hasValueMetric = true
                }
            }
            public func getValueMetricBuilder() -> Events.ValueMetric.Builder {
                if valueMetricBuilder_ == nil {
                    valueMetricBuilder_ = Events.ValueMetric.Builder()
                    builderResult.valueMetric = valueMetricBuilder_.getMessage()
                    if valueMetric != nil {
                        try! valueMetricBuilder_.mergeFrom(other: valueMetric)
                    }
                }
                return valueMetricBuilder_
            }
            @discardableResult
            public func setValueMetric(_ value:Events.ValueMetric!) -> Events.Envelope.Builder {
                self.valueMetric = value
                return self
            }
            @discardableResult
            public func mergeValueMetric(value:Events.ValueMetric) throws -> Events.Envelope.Builder {
                if builderResult.hasValueMetric {
                    builderResult.valueMetric = try Events.ValueMetric.builderWithPrototype(prototype:builderResult.valueMetric).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.valueMetric = value
                }
                builderResult.hasValueMetric = true
                return self
            }
            @discardableResult
            public func clearValueMetric() -> Events.Envelope.Builder {
                valueMetricBuilder_ = nil
                builderResult.hasValueMetric = false
                builderResult.valueMetric = nil
                return self
            }
            public var counterEvent:Events.CounterEvent! {
                get {
                    if counterEventBuilder_ != nil {
                        builderResult.counterEvent = counterEventBuilder_.getMessage()
                    }
                    return builderResult.counterEvent
                }
                set (value) {
                    builderResult.hasCounterEvent = true
                    builderResult.counterEvent = value
                }
            }
            public var hasCounterEvent:Bool {
                get {
                    return builderResult.hasCounterEvent
                }
            }
            fileprivate var counterEventBuilder_:Events.CounterEvent.Builder! {
                didSet {
                    builderResult.hasCounterEvent = true
                }
            }
            public func getCounterEventBuilder() -> Events.CounterEvent.Builder {
                if counterEventBuilder_ == nil {
                    counterEventBuilder_ = Events.CounterEvent.Builder()
                    builderResult.counterEvent = counterEventBuilder_.getMessage()
                    if counterEvent != nil {
                        try! counterEventBuilder_.mergeFrom(other: counterEvent)
                    }
                }
                return counterEventBuilder_
            }
            @discardableResult
            public func setCounterEvent(_ value:Events.CounterEvent!) -> Events.Envelope.Builder {
                self.counterEvent = value
                return self
            }
            @discardableResult
            public func mergeCounterEvent(value:Events.CounterEvent) throws -> Events.Envelope.Builder {
                if builderResult.hasCounterEvent {
                    builderResult.counterEvent = try Events.CounterEvent.builderWithPrototype(prototype:builderResult.counterEvent).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.counterEvent = value
                }
                builderResult.hasCounterEvent = true
                return self
            }
            @discardableResult
            public func clearCounterEvent() -> Events.Envelope.Builder {
                counterEventBuilder_ = nil
                builderResult.hasCounterEvent = false
                builderResult.counterEvent = nil
                return self
            }
            public var error:Events.Error! {
                get {
                    if errorBuilder_ != nil {
                        builderResult.error = errorBuilder_.getMessage()
                    }
                    return builderResult.error
                }
                set (value) {
                    builderResult.hasError = true
                    builderResult.error = value
                }
            }
            public var hasError:Bool {
                get {
                    return builderResult.hasError
                }
            }
            fileprivate var errorBuilder_:Events.Error.Builder! {
                didSet {
                    builderResult.hasError = true
                }
            }
            public func getErrorBuilder() -> Events.Error.Builder {
                if errorBuilder_ == nil {
                    errorBuilder_ = Events.Error.Builder()
                    builderResult.error = errorBuilder_.getMessage()
                    if error != nil {
                        try! errorBuilder_.mergeFrom(other: error)
                    }
                }
                return errorBuilder_
            }
            @discardableResult
            public func setError(_ value:Events.Error!) -> Events.Envelope.Builder {
                self.error = value
                return self
            }
            @discardableResult
            public func mergeError(value:Events.Error) throws -> Events.Envelope.Builder {
                if builderResult.hasError {
                    builderResult.error = try Events.Error.builderWithPrototype(prototype:builderResult.error).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.error = value
                }
                builderResult.hasError = true
                return self
            }
            @discardableResult
            public func clearError() -> Events.Envelope.Builder {
                errorBuilder_ = nil
                builderResult.hasError = false
                builderResult.error = nil
                return self
            }
            public var containerMetric:Events.ContainerMetric! {
                get {
                    if containerMetricBuilder_ != nil {
                        builderResult.containerMetric = containerMetricBuilder_.getMessage()
                    }
                    return builderResult.containerMetric
                }
                set (value) {
                    builderResult.hasContainerMetric = true
                    builderResult.containerMetric = value
                }
            }
            public var hasContainerMetric:Bool {
                get {
                    return builderResult.hasContainerMetric
                }
            }
            fileprivate var containerMetricBuilder_:Events.ContainerMetric.Builder! {
                didSet {
                    builderResult.hasContainerMetric = true
                }
            }
            public func getContainerMetricBuilder() -> Events.ContainerMetric.Builder {
                if containerMetricBuilder_ == nil {
                    containerMetricBuilder_ = Events.ContainerMetric.Builder()
                    builderResult.containerMetric = containerMetricBuilder_.getMessage()
                    if containerMetric != nil {
                        try! containerMetricBuilder_.mergeFrom(other: containerMetric)
                    }
                }
                return containerMetricBuilder_
            }
            @discardableResult
            public func setContainerMetric(_ value:Events.ContainerMetric!) -> Events.Envelope.Builder {
                self.containerMetric = value
                return self
            }
            @discardableResult
            public func mergeContainerMetric(value:Events.ContainerMetric) throws -> Events.Envelope.Builder {
                if builderResult.hasContainerMetric {
                    builderResult.containerMetric = try Events.ContainerMetric.builderWithPrototype(prototype:builderResult.containerMetric).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.containerMetric = value
                }
                builderResult.hasContainerMetric = true
                return self
            }
            @discardableResult
            public func clearContainerMetric() -> Events.Envelope.Builder {
                containerMetricBuilder_ = nil
                builderResult.hasContainerMetric = false
                builderResult.containerMetric = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Events.Envelope.Builder {
                builderResult = Events.Envelope()
                return self
            }
            override public func clone() throws -> Events.Envelope.Builder {
                return try Events.Envelope.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Events.Envelope {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Events.Envelope {
                let returnMe:Events.Envelope = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Events.Envelope) throws -> Events.Envelope.Builder {
                if other == Events.Envelope() {
                    return self
                }
                if other.hasOrigin {
                    origin = other.origin
                }
                if other.hasEventType {
                    eventType = other.eventType
                }
                if other.hasTimestamp {
                    timestamp = other.timestamp
                }
                if other.hasDeployment {
                    deployment = other.deployment
                }
                if other.hasJob {
                    job = other.job
                }
                if other.hasIndex {
                    index = other.index
                }
                if other.hasIp {
                    ip = other.ip
                }
                if other.hasTags {
                    tags = other.tags
                }
                if (other.hasHttpStartStop) {
                    try mergeHttpStartStop(value: other.httpStartStop)
                }
                if (other.hasLogMessage) {
                    try mergeLogMessage(value: other.logMessage)
                }
                if (other.hasValueMetric) {
                    try mergeValueMetric(value: other.valueMetric)
                }
                if (other.hasCounterEvent) {
                    try mergeCounterEvent(value: other.counterEvent)
                }
                if (other.hasError) {
                    try mergeError(value: other.error)
                }
                if (other.hasContainerMetric) {
                    try mergeContainerMetric(value: other.containerMetric)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Events.Envelope.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Events.Envelope.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        origin = try codedInputStream.readString()

                    case 16:
                        let valueInteventType = try codedInputStream.readEnum()
                        if let enumseventType = Events.Envelope.EventType(rawValue:valueInteventType){
                            eventType = enumseventType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueInteventType))
                        }

                    case 48:
                        timestamp = try codedInputStream.readInt64()

                    case 58:
                        let subBuilder:Events.HttpStartStop.Builder = Events.HttpStartStop.Builder()
                        if hasHttpStartStop {
                            try subBuilder.mergeFrom(other: httpStartStop)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        httpStartStop = subBuilder.buildPartial()

                    case 66:
                        let subBuilder:Events.LogMessage.Builder = Events.LogMessage.Builder()
                        if hasLogMessage {
                            try subBuilder.mergeFrom(other: logMessage)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        logMessage = subBuilder.buildPartial()

                    case 74:
                        let subBuilder:Events.ValueMetric.Builder = Events.ValueMetric.Builder()
                        if hasValueMetric {
                            try subBuilder.mergeFrom(other: valueMetric)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        valueMetric = subBuilder.buildPartial()

                    case 82:
                        let subBuilder:Events.CounterEvent.Builder = Events.CounterEvent.Builder()
                        if hasCounterEvent {
                            try subBuilder.mergeFrom(other: counterEvent)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        counterEvent = subBuilder.buildPartial()

                    case 90:
                        let subBuilder:Events.Error.Builder = Events.Error.Builder()
                        if hasError {
                            try subBuilder.mergeFrom(other: error)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        error = subBuilder.buildPartial()

                    case 98:
                        let subBuilder:Events.ContainerMetric.Builder = Events.ContainerMetric.Builder()
                        if hasContainerMetric {
                            try subBuilder.mergeFrom(other: containerMetric)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        containerMetric = subBuilder.buildPartial()

                    case 106:
                        deployment = try codedInputStream.readString()

                    case 114:
                        job = try codedInputStream.readString()

                    case 122:
                        index = try codedInputStream.readString()

                    case 130:
                        ip = try codedInputStream.readString()

                    case 138:
                        let subBuilder = Events.Envelope.TagsEntry.Builder()
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        let buildOfTags = subBuilder.buildPartial()
                        tags[buildOfTags.key] = buildOfTags.value

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Events.Envelope.Builder {
                let resultDecodedBuilder = Events.Envelope.Builder()
                if let jsonValueOrigin = jsonMap["origin"] as? String {
                    resultDecodedBuilder.origin = jsonValueOrigin
                }
                if let jsonValueEventType = jsonMap["eventType"] as? String {
                    resultDecodedBuilder.eventType = try Events.Envelope.EventType.fromString(jsonValueEventType)
                }
                if let jsonValueTimestamp = jsonMap["timestamp"] as? String {
                    resultDecodedBuilder.timestamp = Int64(jsonValueTimestamp)!
                } else if let jsonValueTimestamp = jsonMap["timestamp"] as? Int {
                    resultDecodedBuilder.timestamp = Int64(jsonValueTimestamp)
                }
                if let jsonValueDeployment = jsonMap["deployment"] as? String {
                    resultDecodedBuilder.deployment = jsonValueDeployment
                }
                if let jsonValueJob = jsonMap["job"] as? String {
                    resultDecodedBuilder.job = jsonValueJob
                }
                if let jsonValueIndex = jsonMap["index"] as? String {
                    resultDecodedBuilder.index = jsonValueIndex
                }
                if let jsonValueIp = jsonMap["ip"] as? String {
                    resultDecodedBuilder.ip = jsonValueIp
                }
                if let jsonValueTags = jsonMap["tags"] as? Dictionary<String, String> {
                    var mapTags = Dictionary<String, String>()
                    for (keyTags, valueTags) in jsonValueTags {
                        guard let keyFromTags = String(keyTags) else {
                            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                        }
                        mapTags[keyFromTags] = valueTags
                    }
                    resultDecodedBuilder.tags = mapTags
                }
                if let jsonValueHttpStartStop = jsonMap["httpStartStop"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.httpStartStop = try Events.HttpStartStop.Builder.decodeToBuilder(jsonMap:jsonValueHttpStartStop).build()

                }
                if let jsonValueLogMessage = jsonMap["logMessage"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.logMessage = try Events.LogMessage.Builder.decodeToBuilder(jsonMap:jsonValueLogMessage).build()

                }
                if let jsonValueValueMetric = jsonMap["valueMetric"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.valueMetric = try Events.ValueMetric.Builder.decodeToBuilder(jsonMap:jsonValueValueMetric).build()

                }
                if let jsonValueCounterEvent = jsonMap["counterEvent"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.counterEvent = try Events.CounterEvent.Builder.decodeToBuilder(jsonMap:jsonValueCounterEvent).build()

                }
                if let jsonValueError = jsonMap["error"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.error = try Events.Error.Builder.decodeToBuilder(jsonMap:jsonValueError).build()

                }
                if let jsonValueContainerMetric = jsonMap["containerMetric"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.containerMetric = try Events.ContainerMetric.Builder.decodeToBuilder(jsonMap:jsonValueContainerMetric).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Events.Envelope.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Events.Envelope.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Events.Envelope: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Events.Envelope> {
        var mergedArray = Array<Events.Envelope>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Events.Envelope? {
        return try Events.Envelope.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Events.Envelope {
        return try Events.Envelope.Builder().mergeFrom(data: data, extensionRegistry:Events.EnvelopeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Events.Envelope {
        return try Events.Envelope.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Events.Envelope {
        return try Events.Envelope.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Events.Envelope {
        return try Events.Envelope.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Events.Envelope {
        return try Events.Envelope.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Events.Envelope {
        return try Events.Envelope.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "origin": return self.origin
        case "eventType": return self.eventType
        case "timestamp": return self.timestamp
        case "deployment": return self.deployment
        case "job": return self.job
        case "index": return self.index
        case "ip": return self.ip
        case "tags": return self.tags
        case "httpStartStop": return self.httpStartStop
        case "logMessage": return self.logMessage
        case "valueMetric": return self.valueMetric
        case "counterEvent": return self.counterEvent
        case "error": return self.error
        case "containerMetric": return self.containerMetric
        default: return nil
        }
    }
}
extension Events.Envelope.TagsEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Events.Envelope.TagsEntry> {
        var mergedArray = Array<Events.Envelope.TagsEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Events.Envelope.TagsEntry? {
        return try Events.Envelope.TagsEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Events.Envelope.TagsEntry {
        return try Events.Envelope.TagsEntry.Builder().mergeFrom(data: data, extensionRegistry:Events.EnvelopeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Events.Envelope.TagsEntry {
        return try Events.Envelope.TagsEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Events.Envelope.TagsEntry {
        return try Events.Envelope.TagsEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Events.Envelope.TagsEntry {
        return try Events.Envelope.TagsEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Events.Envelope.TagsEntry {
        return try Events.Envelope.TagsEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Events.Envelope.TagsEntry {
        return try Events.Envelope.TagsEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Events.Envelope.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Events.Envelope
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "origin": return self.origin
            case "eventType": return self.eventType
            case "timestamp": return self.timestamp
            case "deployment": return self.deployment
            case "job": return self.job
            case "index": return self.index
            case "ip": return self.ip
            case "tags": return self.tags
            case "httpStartStop": return self.httpStartStop
            case "logMessage": return self.logMessage
            case "valueMetric": return self.valueMetric
            case "counterEvent": return self.counterEvent
            case "error": return self.error
            case "containerMetric": return self.containerMetric
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "origin":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.origin = newSubscriptValue
            case "eventType":
                guard let newSubscriptValue = newSubscriptValue as? Events.Envelope.EventType else {
                    return
                }
                self.eventType = newSubscriptValue
            case "timestamp":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.timestamp = newSubscriptValue
            case "deployment":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.deployment = newSubscriptValue
            case "job":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.job = newSubscriptValue
            case "index":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.index = newSubscriptValue
            case "ip":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.ip = newSubscriptValue
            case "tags":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.tags = newSubscriptValue
            case "httpStartStop":
                guard let newSubscriptValue = newSubscriptValue as? Events.HttpStartStop else {
                    return
                }
                self.httpStartStop = newSubscriptValue
            case "logMessage":
                guard let newSubscriptValue = newSubscriptValue as? Events.LogMessage else {
                    return
                }
                self.logMessage = newSubscriptValue
            case "valueMetric":
                guard let newSubscriptValue = newSubscriptValue as? Events.ValueMetric else {
                    return
                }
                self.valueMetric = newSubscriptValue
            case "counterEvent":
                guard let newSubscriptValue = newSubscriptValue as? Events.CounterEvent else {
                    return
                }
                self.counterEvent = newSubscriptValue
            case "error":
                guard let newSubscriptValue = newSubscriptValue as? Events.Error else {
                    return
                }
                self.error = newSubscriptValue
            case "containerMetric":
                guard let newSubscriptValue = newSubscriptValue as? Events.ContainerMetric else {
                    return
                }
                self.containerMetric = newSubscriptValue
            default: return
            }
        }
    }
}
extension Events.Envelope.TagsEntry.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Events.Envelope.TagsEntry
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
